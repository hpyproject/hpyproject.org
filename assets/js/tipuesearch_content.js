var tipuesearch = {
  "pages": [
    {
      "title": "hpy 0.9.0: Fourth public release",
      "text": "I'm excited to announce that HPy 0.9 was recently released!\nThe fourth official HPy release comes with many new features\nand was again made available on PyPI.\nThis is the first release that also provides binary wheels, so installation is\nnow fast and smooth as you expect it.\nThe major highlights of the release are support for subclassing of built-in\ntypes, metaclasses, the trace mode, multi-phase module initialization, and the\nhybrid ABI. Please checkout the full release notes here on GitHub:\nhttps://github.com/hpyproject/hpy/releases/tag/0.9.0\nAlso, we invested a lot of effort to improve official\ndocumentation.\nGreat news too is that this release was used to make a first\n(partially-migrated) port of NumPy, we call it\nNumPy/HPy, run some examples.\n\n\nWhat is HPy?\nHPy provides a new API for extending Python in C. In other words, you use\n#include <hpy.h> instead of #include <Python.h>. For more info, look at\nthe\nofficial documentation.\nInstallation\nHPy 0.9 is best tested on Linux and Mac OS X systems but there is also initial\nsupport for Windows (both x86_64). For CPython, you need to install it\nmanually, using pip:\n$ pip install hpy==0.9.0\n\n\n\nPyPy and GraalPy usually\nalready come with intrinsic HPy support, so no installation is necessary.\nHPy 0.9 is already included in GraalPy\n23.1.\nUnfortunately, due to lack of resources, development is still in progress for\nPyPy but should be finished soon.\nAlso checkout PyPy's nightly builds to follow the progress:\n\nPyPy nightly builds\n\nTo check the version of HPy which is shipped with those, you can either use\npip or hpy.universal.get_version().\nMajor Features\n\nSupport subclasses of built-in types\n\nIt is now possible to create pure HPy types that inherit from built-in types like type or float. This was already possible before but in a very limited way, i.e., by setting HPyType_Spec.basicsize to 0. In this case, the type implicitly inherited the basic size of the supertype but that also means that you cannot have a custom C struct. It is now possible inherit from a built-in type AND have a custom C struct. For further reference, see HPyType_Spec.builtin_shape and HPyType_BuiltinShape.\n\nSupport for metaclasses\n\nHPy now supports creating types with metaclasses. This can be done by passing type specification parameter with kind HPyType_SpecParam_Metaclass when calling HPyType_FromSpec.\n\nHPy Hybrid ABI\n\nIn addition to CPython ABI and HPy Universal ABI, we now introduced the Hybrid ABI. The major difference is that whenever you use a legacy API like HPy_AsPyObject or HPy_FromPyObject, the prdouced binary will then be specific to one interpreter. This was necessary to ensure that universal binaries are really portable and can be used on any HPy-capable interpreter.\n\nTrace Mode\n\nSimilar to the Debug Mode, HPy now provides the Trace Mode that can be enabled at runtime and helps analyzing API usage and identifying performance issues.\n\nMulti-phase Module Initialization\n\nHPy now support multi-phase module initialization which is an important feature in particular needed for two important use cases: (1) module state support (which is planned to be introduced in the next major release), and (2) subinterpreters. We decided to drop support for single-phase module initialization since this makes the API cleaner and easier to use.\n\nHPy Calling Protocol\n\nThis was a big missing piece and is now eventually available. It enables slot HPy_tp_call, which can now be used in the HPy type specification. We decided to use a calling convention similar to CPython's vectorcall calling convention. This is: the arguments are passed in a C array and the keyword argument names are provided as a Python tuple. Before this release, the only way to create a callable type was to set the special method __call__. However, this has several disadvantages. In particlar, poor performance on CPython (and maybe other implementations) and it was not possible to have specialized call function implementations per object (see HPy_SetCallFunction)",
      "tags": "",
      "url": "https://hpyproject.org/blog/posts/2023/10/hpy-0.9.0-fourth-public-release/"
    },
    {
      "title": "HPy meetup and CPython core dev sprint in Brno (Oct 7-10, 2023)",
      "text": "We just ended our rather informal HPy meetup in Brno (Czech Republic) which\nstarted on Saturday (October 7th) and lasted until Tuesday (October 10th).\nThe main topics of the HPy meetup were:\n\nThe CPython Core Dev Sprint\nCython/HPy\n\n\n\nThe CPython Core Dev Sprint\nPetr Viktorin, one of the CPython core developers, invited us to\npartially attend the CPython core developer sprint. As a part of the sprint, he\norganized a C API Summit Monday where we were invited and happily attended this\nevent.\nBesides of lots of discussions, there were also very interesting presentations\nabout the C API:\n1. C API Work Group Summary\nIrit\npresented\nthe current status of the C API Work Group GitHub\norganisation. The idea of this GitHub org was to gather curent\nproblems of the C API and also to\ncollect ideas for the (re-)volution of the API. Irit thankfully went over all\nissues and discussions to structure and summarize them. She identified nine\ncategories for problems:\n\nAPI Evolution and Maintenance\nAPI Specification and Abstraction\nObject Reference Management\nType Definition and Object Creation\nError Handling\nAPI Tiers and Stability Guarantees\nThe C Language\nImplementation Flaws\nMissing Functionality\n\nShe also mentioned strengths of the C API which the people contributing to the repository\nagree on:\n\nHeap types\nAPIs taking a C string to look up based on Python strings\nLimited API and Stable ABI\n\nNow, the idea is to write an Informational PEP and then to create:\n\nA process for discussions about replacement APIs\nGuidelines for evolution of the C API.\n\nThe PEP draft is already available.\n2. Petr's Vision for the C API\nPetr presented his understanding of how the C API should look in future. The\nslides\nfor his talk are public. He made seven suggestions:\n\n\nSplit API from ABI so you can compile the API that it would use different ABI\n   variants.\n\n\nConsistency: The API should have a consistent behavior. E.g. APIs should\n   not return borrowed references and the exception behavior should be clear by the\n   naming convention.\n\n\nVersioning: Essentially, a C extension should include the ABI version it\n   was compiled with.\n\n\nErrors: All API functions must be able to signal an error that can be\n   handled.\n\n\nConcrete types: The API should provide dedicated C types for certain\n   built-in objects to have type safety already at the C language level.\n\n\nBlueprint structures: Creating types and objects should rather be done by\n   using specifications than by allocating empty objects and filling them with\n   content. Just think of PyType_Spec or PyModuleDef.\n\n\nContext argument: Every API function should have a context argument.\n\n\nExcept for points 4 and 5, these goals are very close to HPy's. We, the\nHPy team, have to say that this sounds very good and we would be happy to see\nthat in CPython.\n3. HPy's Lessons Learned\nWe were also asked to give a talk\nand to concentrate in the talk on two things:\n\nHow do handles affect the API, and\nWhat is the reason for the HPy context to contain the function table.\n\nWe didn't advertise HPy in our talk but we talked about why opaque handles\nare not only useful but sometimes necessary and how the API would change\ncompared to having only PyObject *.\nWe further showed that having the function table in the context gives us a lot\nof flexibility and finally enables us to switch on the debug mode essentially at\nrun time (when an extension is loaded).\nWe are not sure if we managed to convince everyone that those concepts are useful.\nThe biggest problem is that introducing handles and a context argument will\nradically change the API and require changes in many libraries (see also\nC API Workgroup - API Revolution #2\nand C API Workgroup - API Revolution #7).\n4. Python C API: Past, Present, and Future\nVictor did a thorough presentation\nof the past, present, and (possible) future of the Python C API. He pointed out\nsome past and present problems and gave some impression of its complexity. Victor\nalso suggests to make the stable ABI be the default. Overall, he sees a\npositive trend in how the C API evolves.\nDiscussions\nWe had a lot of good discussions and probably the most important one was about\nthe PEP 703 (noGIL) implementation and the\nnew version of ABI (abi4) that is planned to be compatible with both noGIL and\nGIL builds of CPython. In order to achieve that, Sam, the author of PEP\n703, plans to make PyObject * opaque (so it will narrow to the semantics of a\nhandle) and also, the Py_INCREF will, in some cases, use an indirection over a\nfunction pointer to actually call the incref logic. This is, again, a big step\nforward for alternative implementations.\nCython/HPy\nBesides the main focus on the C API Summit at the CPython Core Dev Sprint, we\nwere also hacking a bit on Cython/HPy and made the doctest system work.\nThe problem there was that the doctest module is binding functions to self in\norder to get a method but HPy did not yet provide the necessary slot\nHPy_tp_descr_get for that. So, we've implemented that and will include it in\nthe next (minor) release.\nWe hoped that we would do more hacking on HPy itself but the CPython core dev\nsprint was worth to spend our time too.",
      "tags": "",
      "url": "https://hpyproject.org/blog/posts/2023/10/hpy-meetup-2023/"
    },
    {
      "title": "HPy - A better C API for Python",
      "text": "What is HPy?\nHPy provides a new API for extending Python in C.  In other words, you use\n#include <hpy.h> instead of #include <Python.h>.\n\n\nWhat are the advantages of HPy?\n\nZero overhead on CPython: extensions written in HPy run at the same\nspeed as \"normal\" extensions.\nMuch faster on alternative implementations such as PyPy, GraalPy.\nUniversal binaries: extensions built for the HPy Universal ABI can be\nloaded unmodified on CPython, PyPy, GraalPython, etc.\nA migration path for mixing legacy C-API calls with HPy API calls. Once\nall the code is migrated, the extension can be compiled as a universal binary\nthat works on any CPython version, PyPy, or GraalPy.\nDebug mode: in debug mode, you can easily identify common problems such\nas memory leaks, invalid lifetime of objects, invalid usage of APIs. Have\nyou ever forgot a Py_INCREF or Py_DECREF? The HPy debug mode can be\nactivated at runtime to detect these mistakes for you on universal binaries.\nNicer API: the standard Python/C API shows its age. HPy is designed to\novercome some of its limitations, be more consistent, produce better quality\nextensions and to make it harder to introduce bugs.\nEvolvability: As nicely summarized in\nPEP 620 the standard Python/C API\nexposes a lot of internal implementation details which makes it hard to\nevolve the C API. HPy doesn't have this problem because all internal\nimplementation details are hidden.\n\n\n\nCurrent status\nHPy is under active development. 0.9.0 is the latest alpha release but we\nwill soon leave the _alpha_ state and are working hard towards a stable release.\nWe feel that the HPy ABI is stable enough now that we can fulfill our backwards\nand forwards binary compatibility promises with the upcoming release, and that\nthe API now covers enough use cases to migrate important packages (in\nparticular, checkout our numpy port). We also provide porting guides and\nextensive documentation (in particular the API reference).\nWe are, of course, always open for design discussions and new reqiurements.\nThe Python/C API is huge. At the moment many popular functions are\navailable. Is something missing for the port of your favorite extension?\nPlease open an issue or even better a PR.\n\nHPy-compatible extensions\nThe extensions that we are experimenting with include:\n\nultrajson-hpy: this was the first real-world module to be ported to HPy. It is\na nice fit because it only exports functions (as opposed as custom types)\nand requires only a small number of API functions.\npiconumpy: as the name suggests, this is a minimal numpy-like module which\ndefines a custom type (similar to ndarray but with many fewer features of\ncourse).\nnumpy: one of our ambitious goals is to port numpy to HPy, and to use this\nexperience to better understand how to design the API. This port is close to\npassing the test suite.\nmatplotlib: Since Matplotlib also has a dependency to NumPy, the migration\nto universal mode is not fully finished. HPy provides the legacy compatibility API\nsuch that we can still call legacy C API functions from HPy and successfully\nrun the test suite.\nkiwi-solver: A dependency of Matplotlib, it has been fully ported to\nuniversal mode.\n\nBenchmarks and more information about the Matplotlib and kiwi-solver ports can\nbe found in the GraalVM blog post. The benchmarks show that the HPy ports\nhave little impact on CPython performance, while enabling close-to-cpython\nperformance with GraalVM Python for the kiwi-solver complete HPy port.\n\n\n\nWhere we need help\n\nDocumentation: Our resources are very limited and we therefore concentrate\non technical tasks. We already wrote a significant amount of documentation\n(see Documentation) but it is not complete yet. If this non-coding work is\nsomething you can do, let us know.\nPublicity: HPy is already well received among core developers of some\nimportant projects. For instance, we are actively talking to Python, NumPy,\nand Cython core developers. However, we need to get more package developers to\nbe interested in and even use HPy. We appreciate any help for advertising HPy\nand we are also happy to help preparing talks, demos, etc.\nTooling: This is also a topic we would need help. We are, for example,\nthinking of migration helper tools that do all the boilerplate work that can\nbe automated when migrating a package from C API to HPy API.\nPackaging: There are several open questions we need to discuss and answer.\n\nHow to package a universal extension and how to put it on PyPI?\nHow best to package HPy itself\nHow does HPy integrate with setuptools, mesonpy, or other build systems\nUpstreaming completed forks of the packages listed below, or upstreaming\nparts of the forks so the code does not suffer from bit-rot\n\n\nWebsite and logo design: You don't like this website and the HPy logo?\nWell, we have expertise in virtual machines, compilers, low-level programming,\netc, but zero expertise in web development or graphic design. PRs are welcome\n;)\n\n\n\nMore info\n\nDocumentation\nHPy blog\nGithub repository\nHPy Discord server\n#hpy IRC channel (obsolete but still there)\nMailing list\nHPy is pronounced /h/ - pie (or using IPA notation: /e\u026at\u0283-pa\u026a/)\n\n\n\nRecent blog posts\n\n\n    \n            \n            2023-10-12 19:00\n            \u00a0\n            hpy 0.9.0: Fourth public release\n            \n            \n            2023-10-10 10:00\n            \u00a0\n            HPy meetup and CPython core dev sprint in Brno (Oct 7-10, 2023)\n            \n            \n            2022-09-26 10:00\n            \u00a0\n            HPy Sprint Status Update and Feedback Session\n            \n            \n            2022-09-08 15:30\n            \u00a0\n            HPy on GraalPy and Matplotlib/HPy\n            \n            \n            2022-07-29 10:00\n            \u00a0\n            Dusseldorf PyPy/HPy/other sprint Sept 19-23, 2022",
      "tags": "",
      "url": "https://hpyproject.org/"
    },
    {
      "title": "HPy Sprint Status Update and Feedback Session",
      "text": "As we announced in\nthis blog post,\nwe are currently having our joint PyPy/HPy/GraalPy sprint in D\u00fcsseldorf.\nOn Thursday (September 22nd, 2022), we did the HPy sprint report. Most notably,\nwe also had several CPython core developers in the call.\nThe sprint report was streamed on\nTwitch and the recording is available here:\n\n\n\n\nHPy Sprint Call with CPython Core Developers\nOne of the main goals in the sprint was to write a PEP to officially propose\nHPy as an Python C extension API. We started to do so but before we actually\nsubmit this PEP, we wanted to have some feedback. So, we invited the Python\ncore developers to our call and some of them joined.\nWe gave a short overview of HPy since not everyone might know it yet.\nWe talked about the goals and non-goals of HPy and basically asked if Python\ncore developers would be willing to participate in HPy design discussions.\nWe discussed PSF endorsement and the conclusion was that we need to talk to\nthe PSF.\nWe had some very good discussions and we also got some valuable feedback.\nOur next steps are now to incorporate this feedback and prepare the PEP to\ncontinue discussions there and gather more feedback.\nWe thank the Python core developers for participating in the call and for the\noffered support.\nCall with NumPy Core Developer Sebastian Berg\nSince we are working on the migration of NumPy to HPy, we had a call with\nSebastian Berg on Tuesday (September 20th, 2022).\nWe discussed some problems we discovered during our migration work and were\ndiscussing how to solve it.\nThese were the main discussion points:\n\n\nNumPy's structured data type allows to have objects in NumPy arrays which\n  problematic for HPy. This is mainly because doesn't allow to use the API\n  during deallocation of an object. Hence, there is no way to determine the\n  location of those objects by fetching the data type (which requires an API\n  call). We discussed to mirror the structure in pure C-level data structures\n  instead.\n\n\nHPy requires to migration all static types to heap types and we discovered\n  that static type behave a bit differently compared to heap types in the case\n  of multiple inheritance. We discussed if that is a bug that CPython needs\n  to solve or if that is something that NumPy should change. So far, it looks\n  rather to be a CPython problem since heap types are pretty new.\n\n\nWe further discussed how to handle NumPy's C API when migrating to HPy. We\n  agreed that we will probably need to provide a separate NumPy HPy C API as\n  well which will maybe removed at some point in future.\n\n\nMain Technical Achievements of the Sprint\n\n\nWe have added support for stack traces when running in the debug mode on Mac\n  OS X (PR 346).\n\n\nWe are up to finish our incremental porting example\n  (PR 246)\n\n\nHPy does now also correctly support object members in HPy types\n  (PR 347).",
      "tags": "",
      "url": "https://hpyproject.org/blog/posts/2022/09/hpy_sprint_2022_report/"
    },
    {
      "title": "HPy on GraalPy and Matplotlib/HPy",
      "text": "Recently, the\nGraalVM Python team started a series of blog\nposts on Medium about\nHPy on GraalPy\nand about the\nmigration of Matplotlib to HPy\n. The second blog post is in particular interesting since it not only describes\nthe migration process but also shows performance numbers. The source code is\nalso publicly available.",
      "tags": "",
      "url": "https://hpyproject.org/blog/posts/2022/09/hpy_on_graal_and_mpl/"
    },
    {
      "title": "Dusseldorf PyPy/HPy/other sprint Sept 19-23, 2022",
      "text": "I'm happy to announce that we will finally have another PyPy/HPy/other sprint\nin D\u00fcsseldorf, Germany from September 19-23, 2022.\nThe sprint will be located at Heinrich Heine University D\u00fcsseldorf. Many\nthanks to Carl Friedrich for organizing this.\nWe will again follow an open format, i.e., everyone that is interesting in HPy,\nPyPy, or some related topic is welcome to join the sprint.\nSee also the\nannouncement on the PyPy blog.\n\n\nGoals and topics of the sprint\nFrom the HPy point of view, there is no strict agenda. The main goal of the\nsprint is to make progress on HPy in any way you can think of.\nThis includes but is not limited to:\n\nReview, discuss, maybe merge open GitHub PRs.\nHacking on HPy: implement new features, fix bugs, etc.\nCome up with ideas for blog posts or even write blog posts.\nMigrate packages to HPy or just determine candidates for migration.\nDocument the HPy API.\nCreate small documented and tested porting examples and/or a small porting\n  guide.\n\nAccommodation\nWe do not organize an accommodation. A hotel close the campus is the\nHK-Hotel D\u00fcsseldorf but we rather\nrecommend to book something in the city center since we will usually end up\nthere in the evenings. The convenient parts of town are something like\nAltstadt, Stadtmitte, Friedrichstadt, Carlstadt, or Unterbilk.\nRegistration\nThere is no formal registration nor any fee for participation. Just to know who\nwe should expect to show up, please follow the instructions on\nthe PyPy blog.",
      "tags": "",
      "url": "https://hpyproject.org/blog/posts/2022/07/dusseldorf-sprint-2022/"
    },
    {
      "title": "hpy 0.0.4: Third public release",
      "text": "HPy 0.0.4 is out! The third official HPy release comes with many new features\nand was again made available on PyPI.\nMajor highlights of the release are a bunch of new API functions (e.g.\nHPyErr_ExceptionMatches, HPyErr_WarnEx, HPy_Contains, and more),\nPython 3.10 support, better support for native fields (HPyField) and global\nvariables (HPyGlobal), new debug mode features (detect invalid raw data\npointer usage, detect invalid closing of argument handles, detect return of\ninvalid handles).\nGreat news too is that we are now able to provide two more non-trivial projects\nthat have been (partially) migrated to HPy. This is,\nKiwisolver\nand Matplotlib.\n\n\nWhat is HPy?\nHPy provides a new API for extending Python in C. In other words, you use\n#include <hpy.h> instead of #include <Python.h>. For more info, look at\nthe\nofficial documentation.\nInstallation\nHPy 0.0.4 is best tested on Linux systems but there is also initial support for\nWindows (both x86_64).\nFor CPython, you need to install it manually, using pip:\n$ pip install hpy==0.0.4\n\n\n\nPyPy and GraalPython already\ncome with intrinsic HPy support, so no installation is necessary. HPy 0.0.4 will\nbe included in the next release of both. In the meantime, you can download a\nnightly or dev build:\n\n\nPyPy nightly builds\n\n\nGraalVM CE dev builds\n\n\nTo check the version of HPy which is shipped with those, you can either use\npip or hpy.universal.get_version():\n$ pypy -m pip show hpy\nName: hpy\nVersion: 0.0.4\n...\n\n$ graalpython -m pip show hpy\nName: hpy\nVersion: 0.0.4\n...\n\n$ pypy -c 'import hpy.universal; print(hpy.universal.get_version()[0])'\n0.0.4\n\n$ graalpython -c 'import hpy.universal; print(hpy.universal.get_version()[0])'\n0.0.4\n\n\n\nAPI\nWe are constantly working on the HPy API and keep adding functions that are\nmissing. We've added following API functions to the new release:\n\nHPyErr_SetFromErrnoWithFilename, HPyErr_SetFromErrnoWithFilenameObjects\nHPyErr_ExceptionMatches\nHPyErr_WarnEx\nHPyErr_WriteUnraisable\nHPy_Contains\nHPyLong_AsVoidPtr\nHPyLong_AsDouble\nHPyUnicode_AsASCIIString, HPyUnicode_DecodeASCII\nHPyUnicode_AsLatin1String, HPyUnicode_DecodeLatin1\nHPyUnicode_DecodeFSDefault, HPyUnicode_DecodeFSDefaultAndSize\nHPyUnicode_ReadChar\n\nFor an overview of the current API, please refer to the public API declaration\nin public_api.h,\nwhich is used to autogenerate parts of the HPy code and is a reliable list of\nall the supported functions. Also have a look at additional helpers in\ninline_helpers.h.\n\nWarning\nThe HPy API is still considered in alpha status and it's subject to change\nbetween versions.\n\nDebug Mode\nWe again improved HPy's debug mode and added following new features:\nEnable Debug Mode via Environment Variable\nThe debug mode can now be enabled using environment variable HPY_DEBUG. It is\npossible to enable the debug mode for all HPy extensions or it is also possible\nto enable it just for certain extensions by enumerating them.\nExample:\n$ # enable debug mode for all HPy extensions\n$ HPY_DEBUG=1 python3 my_application.py\n\n$ # enable debug mode just for ujson_hpy and piconumpy_hpy\n$ HPY_DEBUG=ujson_hpy,piconumpy_hpy python3 my_application.py\n\n\n\nDetect Invalid Use of Raw Data Pointers\nSome API functions return a raw data pointer from an object. For example:\nconst char* HPyUnicode_AsUTF8AndSize(HPyContext *ctx, HPy h, HPy_ssize_t *size)\n\n\n\nreturns a raw data pointer to the UTF8 representation of a Python unicode\nobject. HPy doesn't expose the internal representation of the unicode object, so\nthe Python implementation may use an arbitrary internal representation. This\nmeans that the UTF8 representation is just temporarily created for this API call\nand so the raw data must be released at some point. The contract here is that\nthe raw data pointer is valid as long as the corresponding handle is valid.\nExample:\n#include <string.h>\n\nstatic const char *s_hello_world = \"Hello, World!\";\n\nstatic const char * foo(HPyContext *ctx)\n{\n    HPy h_unicode = HPyUnicode_FromString(ctx, s_hello_word);\n    HPy_ssize_t size;\n    const char *res = HPyUnicode_AsUTF8AndSize(ctx, h_unicode, &size);\n\n    /* closing 'h_unicode' is, of course, correct */\n    HPy_Close(ctx, h_unicode);\n\n    /* raw data pointer 'res' may have become invalid when closing\n       'h_unicode' */\n    return res;\n}\n\nstatic int bar(HPyContext *ctx)\n{\n    const char *s = foo(ctx);\n\n    /* accessing 's' will cause a fatal error in debug mode (on supported\n    systems) */\n    return strcmp(s, s_hello_world) == 0;\n}\n\n\n\nIt is easy to forget about this resriction and if the raw data pointer is used\nafter the handle was closed, it may point to garbage. If the debug mode is\nenabled, it will make the underlying memory inaccessible and every access to the\npointer will then cause a crash of the application. This is currently only\nimplemented for Linux systems. We use a different strategy on other systems and\nfill the pointer with some marker bytes that make it easy to detect.\nDetect Incorrect Closing of Argument Handles\nHPy functions that are called from Python receive handles that are owned by the\ncaller. This means that those handles must not be closed by the callee but it\nis, of course, possible to erroneously call HPy_Close on them. For example:\nHPyDef_METH(foo, \"foo\", foo_impl, HPyFunc_O, .doc=\"closing argument\")\nstatic HPy foo_impl(HPyContext *ctx, HPy self, HPy arg)\n{\n    // error: 'arg' is owned by the caller\n    HPy_Close(ctx, arg);\n    return HPy_Dup(ctx, ctx->h_None);\n}\n\n\n\nDetect Invalid Handles Returned from Function\nA common problem when returning handles is that the author may easily forget to\ncreate a new handle. The debug mode now detects situations like the following:\nHPyDef_METH(foo, \"foo\", foo_impl, HPyFunc_NOARGS, .doc=\"returns arg w/o dupping it\")\nstatic HPy foo_impl(HPyContext *ctx, HPy self)\n{\n    // should be: return HPy_Dup(ctx, self);\n    return self;\n}\n\n\n\nExamples\nBesides the known examples, this is HPy's\n\"proof of concept\" package,\nultrajson-hpy,\npiconumpy, we are\nexcited to present two new packages we have migrated to HPy:\n\n\nKiwi\n  is an efficient C++ implementation of the Cassowary constraint solving\n  algorithm.\n\n\nMatplotlib\n  is a comprehensive library for creating static, animated, and interactive\n  visualizations in Python.\n  Since Matplotlib also has a dependency to NumPy, the migration is not fully\n  finished but luckily, HPy provides the legacy compatibility API such that we\n  can still call legacy C API functions from HPy.\n\n\nWe are still cleaning these ports up and will write another blog post about the\nports and open them for discussion with the project owners.",
      "tags": "",
      "url": "https://hpyproject.org/blog/posts/2022/06/hpy-0.0.4-third-public-release/"
    },
    {
      "title": "hpy 0.0.3: Second public release",
      "text": "HPy 0.0.3 is out! This is already HPy's second officially released version and\nwas again made available on PyPI.\nThe major highlights of this release are new API functions, new debug mode\nfeatures, and Windows support.\n\n\nWhat is HPy?\nHPy provides a new API for extending Python in C. In other words, you use\n#include <hpy.h> instead of #include <Python.h>. For more info, look at\nthe\nofficial documentation.\nInstallation\nHPy 0.0.3 is best tested on Linux systems but there is also initial support for\nWindows (both x86_64).\nFor CPython, you need to install it manually, using pip:\n$ pip install hpy==0.0.3\n\n\n\n\nNote\nCurrently, we provide only the sdist (i.e., the .tar.gz, no binary\nwheels). But we plan to ship binary wheels starting with the next release.\n\nPyPy and GraalPython already\ncome with intrinsic HPy support, so no installation is necessary. HPy 0.0.3 is\nincluded in the current releases of both, i.e. PyPy 7.3.6 (released on\n2021-10-17) and GraalPython 21.3.0 (released on 2021-10-19).\nTo double check the version of HPy which is shipped with those, you can either\nuse pip or hpy.universal.get_version():\n$ pypy -m pip show hpy\nName: hpy\nVersion: 0.0.3\n...\n\n$ graalpython -m pip show hpy\nName: hpy\nVersion: 0.0.3\n...\n\n$ pypy -c 'import hpy.universal; print(hpy.universal.get_version()[0])'\n0.0.3\n\n$ graalpython -c 'import hpy.universal; print(hpy.universal.get_version()[0])'\n0.0.3\n\n\n\nAPI\nHPy is still under heavy development and does not yet provide as many API\nfunctions as Python's C API, but more and more pieces are being added.\nIn this release, we've added following functions:\n\nHPy_Is\nHPyBytes_FromStringAndSize\nHPyErr_NewException\nHPyErr_NewExceptionWithDoc\nHPyUnicode_AsUTF8AndSize\nHPyUnicode_DecodeFSDefault\nHPyImport_ImportModule\n\nAll of the above functions except of HPy_Is have equivalents in the C API. You\njust need to remove the leading H from the name.\nFunction HPy_Is was added to be able to do object identity comparisons. In the\nC API, you would just do a pointer comparison like this:\nPyObject *object_a = /* ... */;\nPyObject *object_b = /* ... */;\nreturn object_a == object_b;\n\n\n\nIn HPy, direct comparisons of handles are forbidden by design, because distinct\nhandles can point to the same object. To compare objects by identity, you need\nto use HPy_Is:\nHPy object_a = /* ... */;\nHPy object_b = /* ... */;\nreturn HPy_Is(ctx, object_a, object_b);\n\n\n\nWe've also extended functions HPyArg_Parse and HPyArg_ParseKeywords and\nadded support for format specifier s. The new specifier converts a Python\nunicode object into a C string. For example:\nconst char *result;\nif (!HPyArg_Parse(ctx, NULL, args, nargs, \"s\", &result)) {\n    return HPy_NULL;\n}\nprintf(\"result = %s\\n\", result);\n\n\n\nFor an overview of the current API, please refer to the public API declaration\nin public_api.h,\nwhich is used to autogenerate parts of the HPy code and is a reliable list of\nall the supported functions.\n\nWarning\nThe HPy API is still considered in alpha status and it's subject to change\nbetween versions.\n\nDebug Mode\nOne of the great features of HPy is the debug mode. It was already introduced\na while ago (and therefore already included in release 0.0.2) but it got a new\nfeature that can help C extension developers a lot. HPy's debug mode is now able\nto track closed handles. Previously, it was not guaranteed that accesses to\nclosed handles will cause a fatal error. This is because it's possible that\nanother object is associated with the closed handle. Then the program would just\noperate on the wrong object. The new feature is able to prevent that.\nExamples\nThe best way to get a glimpse of how to use HPy is to look at examples:\n\n\nthe HPy repository contains a\n  \"proof of concept\" package.\n  Make sure to checkout the branch release/0.0.3.\n\n\nultrajson-hpy\n  is a port of the popular ultrajson package. Make sure to checkout the\n  hpy-0.0.3 branch.\n\n\npiconumpy\n  contains a very tiny implementation of an array-like class. Make sure to\n  checkout the hpy-0.0.3 branch.",
      "tags": "",
      "url": "https://hpyproject.org/blog/posts/2021/10/hpy-0.0.3-second-public-release/"
    },
    {
      "title": "hpy 0.0.2: First public release",
      "text": "HPy 0.0.2 is out! This is the first version which is officially released and\nmade available on PyPI.\nThe major highlight of this release is that it is supported by three different\nPython implementations: CPython, PyPy and GraalPython.\n\n\nWhat is HPy?\nHPy provides a new API for extending Python in C. In other words, you use\n#include <hpy.h> instead of #include <Python.h>. For more info, look at\nthe\nofficial documentation.\nInstallation\nHPy 0.0.2 only supports Linux systems, and it's only tested on\nx86_64. Windows support is already present on master, and it will be\nincluded in the next release.\nFor CPython, you need to install it manually, using pip:\n$ pip install hpy==0.0.2\n\n\n\n\nNote\nCurrently, we provide only the sdist (i.e., the .tar.gz, no binary\nwheels). See also\nissue #223, contributions\nare welcome :).\n\nPyPy and GraalPython ships their own version of HPy, so no installation is\nnecessary. HPy 0.0.2 will be included in the next release of both, i.e. PyPy\n7.3.6 (expected in October 2021) and GraalPython 21.2.0 (expected on\n2021-07-20). In the meantime, you can download a nightly build:\n\n\nPyPy 3.7 nightly builds, for example revision 3bf99c09018b\n\n\nGraalPython: download the latest graalpython-dev package from\n  this page\n\n\nTo double check the version of HPy which is shipped with those, you can either\nuse pip or hpy.universal.get_version():\n$ pypy -m pip show hpy\nName: hpy\nVersion: 0.0.2\nSummary: A better C API for Python\nHome-page: https://hpyproject.org\nAuthor: The HPy team\nAuthor-email: hpy-dev@python.org\nLicense: MIT\n...\n\n$ pypy -c 'import hpy.universal; print(hpy.universal.get_version()[0])'\n0.0.2\n\n\n\nAPI\nAt the moment HPy supports only a small fraction of the full API offered by\nthe old Python/C API, but it is enough to write non-trivial extensions, and\nthe documentation is\nscarce. public_api.h,\nwhich is used to autogenerate parts of the HPy code, is a reliable list of all\nthe supported functions.\n\nWarning\nThe HPy API is still considered in alpha status and it's subject to change\nbetween versions. In fact, the current master is already incompatible with\nhpy-0.0.2 because of\nPR #182, which renamed all\noccurences of HPyContext into HPyContext*.\n\nExamples\nThe best way to get a glimpse of how to use HPy is to look at examples:\n\n\nthe HPy repository contains a\n  \"proof of concept\" package.\n  Make sure to checkout the branch release/0.0.2.\n\n\nultrajson-hpy\n  is a port of the popular ultrajson package. Make sure to checkout the\n  hpy-0.0.2 branch.\n\n\npiconumpy\n  contains a very tiny implementation of an array-like class. Make sure to\n  checkout the hpy-0.0.2 branch.",
      "tags": "",
      "url": "https://hpyproject.org/blog/posts/2021/07/hpy-0.0.2-first-public-release/"
    },
    {
      "title": "#hpy IRC moves to Libera.Chat",
      "text": "Following the example of many other FOSS projects, the HPy team has\ndecided to move its official #hpy IRC channel from Freenode to\nLibera.Chat: irc.libera.chat/hpy\nThe core devs will no longer be present on the Freenode channel, so we recommend to\njoin the new channel as soon as possible.\nwikimedia.org has a\nnice guide on\nhow to setup your client to migrate from Freenode to Libera.Chat.",
      "tags": "",
      "url": "https://hpyproject.org/blog/posts/2021/05/hpy-irc-moves-to-libera-chat/"
    },
    {
      "title": "HPy @ Python Language Summit",
      "text": "Yesterday I had the privilege to give a talk about HPy\n(sildes) at the\nPython Language Summit 2021.\nThe organizers of the summit will soon publish a full report about the event\n(edit: now available\nhere),\nbut for the HPy-specific\npart,\nwe got generally good feedback. Someone has a few concerns that if CPython is\nto change the API, HPy might not be going far enough. Others said that Python\nshouldn't wait for the \"perfect\" API if HPy can be the \"good\" one that helps it\nevolve.\nEveryone was open to have HPy-compatible wheels on PyPI, once the HPy\nUniversal ABI stays relatively stable. Many people suggested that we should\nreally write a PEP to propose HPy as a \"semi-official\" API for Python.\n\n\nAn interesting question was about which are the VM optimizations which are\ncompatible with the HPy API. The following is a non-exhaustive list of things\nwhich are known to work because they already used by PyPy and/or GraalPython:\n\nJIT compiler\nmoving/compacting GCs\nstorage strategies\nmaps (also known as \"hidden classes\")\n\nOne notable missing optimization from the list above is tagged\npointers. Currently there is no implementation which uses tagged pointers and\nsupports HPy. However, we don't think there is any fundamental design issue in\nHPy which would prevent it: if you turn tagged pointers into \"tagged handles\",\nthings should just work out of the box.",
      "tags": "",
      "url": "https://hpyproject.org/blog/posts/2021/05/hpy-python-language-summit/"
    },
    {
      "title": "HPy Status Update",
      "text": "HPy's first git commit was on Friday, 12 July 2019. Despite the crazy state\nof the world, HPy has come a long way\nsince then. This is a quick update to say where we are now and what's planned\nfor the immediate future.\n\n\nWhat can one do with HPy right now?\nOne can already port non-trivial Python extensions to the HPy API, but\nthere is also still a lot of work to do. Things one can do right now\nwith HPy include:\n\nInitialize an extension module\nCreate custom extension types\nCreate custom methods and functions\nInteract with many built-in types (including dictionaries, tuples,\n  lists, strings, bytes and longs)\nRaise and check exceptions\nParse arguments to C functions\nCall Python functions\nCompile an extension against either the \"universal\" or \"cpython\" ABIs (see below)\nLoad a single compiled \"universal\" extension into different Python implementations.\nPut a \"universal\" extension into debug mode at runtime (see below\n  for how this is possible without a performance penalty).\nCompile extensions for POSIX and Windows (MSVC).\n\nAn extension written using HPy may be compiled against either the \"cpython\" or\n\"universal\" ABI:\n\n\ncompiling against the \"cpython\" ABI produces an ordinary Python C extension.\n  The extension uses the HPy API only internally. From the point of view of\n  the Python implementation the compiled module is an ordinary C extension\n  that just happens to have been compiled using HPy. Note that as is the case\n  for ordinary C extensions, the modules produced target a specific\n  ABI tag.\n\n\ncompiling against the \"universal\" ABI produces an HPy C extension. This\n  extension does not use the Python C API directly at all and the ABI\n  is unique (up to platform and HPy version number). The same compiled module\n  may thus be loaded by multiple Python versions and implementations.\n  A Python implementation must know how to load such an extension and have\n  implemented the HPy universal ABI. Universal ABI implementations exist for\n  CPython, PyPy and GraalPython.\n\n\nDebug mode is implemented by replacing the HPy context with a debug mode\ncontext at runtime. The debug context wraps the original context and tracks\nall HPy API calls. Debug mode already supports finding handles that are\nleaked (i.e. not closed) and handles that are used after being closed.\nAdditional debug features will be fairly straightforward to add, like for example checking for NULL pointers or detecting whether the user is trying to call a function without holding the GIL.\nThe debug mode is written using HPy itself, so its implementation can be\nshared by different Python implementations that support HPy.\nWhat are the next steps?\nThe big picture is that we're working towards writing a Cython backend\nand porting core features of numpy to HPy. There is still some way to go\nbut the immediate next steps planned are:\n\n\nAdd support for storing long-lived references to other Python objects in\n  custom types, i.e. the equivalent of storing a PyObject * in\n  one of the fields with the struct of a custom type. HPy handles are only for\n  short-lived references, so we need a GC-friendly way to store long-lived\n  references.\n  See issue #9.\n\n\nImplement isolated module level state, to avoid using C static global\n  variables. This will be the HPy equivalent of\n  PEP 573 and\n  PEP 630.\n\n\nImplement multi-phase Python module initialization (HPy currently uses the\n  legacy module initialization).\n  See issue #183.\n\n\nUpdate the PyPy and GraalPython HPy implementations to support all the\n  latest HPy features.\n\n\nStart work on an HPy backend for Cython.\n\n\nContinuing work on a minimal port of numpy's array type to HPy.\n\n\nAsk the CPython core developers whether we can find a way to support\n  HPy universal extensions directly within in CPython (currently we write\n  a small .py file that knows how to load the universal extension, but\n  the presence of this stub file causes many small edge cases that are\n  annoying for HPy developers and users)\n\n\nIf you'd like to work on any of these with us, drop us a note in the\ncomments or mailing list or join us on IRC.\nHappy hacking,\nThe HPy Team.",
      "tags": "",
      "url": "https://hpyproject.org/blog/posts/2021/05/may-status-update/"
    },
    {
      "title": "Hello, HPy",
      "text": "Welcome to the shiny new HPy blog!\nHPy has been around for a while now. The initial discussion started during\nEuroPython 2019, in the good old times when we could still go to conferences\nand have real-life meetings. Since then, HPy progressed a lot from the\npoint of view of the actual code, but we have been a bit too silent\nw.r.t. communicating what we are doing to the external world and to the broader\nPython community. Hopefully, now that this blog is online we will do a better\njob at periodically communicating the status of HPy, so make sure to\nsubscribe to the RSS feed.\n\n\nWhat is HPy?\nQuoting the frontpage of our website:\n\nHPy provides a new API for extending Python in C. In other words, you use\n#include <hpy.h> instead of #include <Python.h>.\n\nThe official Python/C API is\nspecific to the current implementation of CPython: it exposes many\ninternal details which makes it hard:\n\n\nto implement it for other Python implementations (e.g. PyPy, GraalPython,\n  Jython, IronPython, etc.)\n\n\nto experiment with new things inside CPython itself: e.g. using a GC\n  instead of refcounting, or to remove the GIL.\n\nto correctly check things like refcount handling: the external API gets mixed in with implementation details that should be hidden.\n\nOver the years, it has become evident that\nemulating the Python/C API in an efficient way is challenging,\nif not impossible. The main goal of HPy is expose a C API which is possible\nto implement in an efficient way on a number of very diverse Python\nimplementations.\nThere are several advantages to writing your C extension in HPy:\n\n\nit runs much faster on PyPy, and at native speed on CPython\n\n\nit is possible to compile a single binary which runs unmodified on all\n  supported Python implementations and versions\n\n\nit is simpler and more manageable than the Python/C API\n\n\nit provides an improved debugging experience: in \"debug mode\", HPy\n  actively checks for many common mistakes such as reference leaks and\n  invalid usage of objects after they have been deleted. It is possible to\n  turn the \"debug mode\" on at startup time, without needing to recompile\n  Python or the extension itself\n\n\nSee also the official docs for a more in-depth\noverview.\nShow me an example\nThis is a \"normal\" Python/C extension:\n2021/03/hello-hpy/hello_old.c  (Source)#include <Python.h>\n\nstatic PyObject* add(PyObject* self, PyObject* args) {\n    long a, b;\n    if (!PyArg_ParseTuple(args, \"ll\", &a, &b))\n        return NULL;\n    return PyLong_FromLong(a+b);\n}\n\nstatic PyMethodDef HelloMethods[] = {\n    {\"add\", (PyCFunction)add, METH_VARARGS, \"add two integers\"},\n    {NULL, NULL, 0, NULL}\n};\n\nstatic struct PyModuleDef moduledef = {\n    PyModuleDef_HEAD_INIT,\n    \"hello_old\",\n    \"hello example using the old Python/C API\",\n    -1,\n    HelloMethods,\n};\n\nPyMODINIT_FUNC\nPyInit_hello_old(void) {\n    return PyModule_Create(&moduledef);\n}\n\n\nWe can compile it with a simple setup.py:\nfrom setuptools import setup, Extension\nsetup(\n    name=\"hello\",\n    ext_modules = [\n        Extension('hello_old', ['hello_old.c']),\n    ],\n)\n\n\n\n$ python setup.py build_ext --inplace\n...\n$ python\n>>> import hello_old\n>>> hello_old.add(10, 20)\n30\n\n\n\nNow, let's start to uncover the HPy equivalent, piece by piece:\n#include <hpy.h>\n\nHPyDef_METH(add, \"add\", add_impl, HPyFunc_VARARGS,\n            .doc = \"add two integers\");\n\nstatic HPy add_impl(HPyContext ctx, HPy self, HPy *args, HPy_ssize_t nargs) {\n    long a, b;\n    if (!HPyArg_Parse(ctx, NULL, args, nargs, \"ll\", &a, &b))\n        return HPy_NULL;\n    return HPyLong_FromLong(ctx, a+b);\n}\n\n\n\nThere are a bunch of things which are different from the usual C-extension module:\n\n\nthe former PyObject * is now HPy, which we call \"a handle\". Handles are\n  similar to PyObject *, but are completely opaque: for more information,\n  see the\n  official docs.\n\n\nThere is an additional parameter, HPyContext ctx. One of the problems of\n  the old API is that often it implicitly relies on the existence of a\n  per-thread or per-subinterpreter local state. HPyContext makes this state explicit. This\n  makes the whole API more regular and makes it possible to develop new\n  interesting features such as the\n  Universal ABI\n  and the Debug mode.\n\n\nHPy introduces the concept of HPyDefs. HPyDef_METH is a macro which\n  generates the definition of an HPyDef static constant named add, which\n  represents the definition of a Python method implemented by the C function\n  add_impl. In this specific example HPyDef_METH contains more or less the\n  same informations as the old PyMethodDef, but HPyDef are more\n  general. For example, when defining custom types you can use things like\n  HPyDef_SLOT, HPyDef_GETSET, etc.\n\n\nNotice that we no longer need the cast to (PyCFunction). One of the\n  biggest advantages of HPyDef_METH is that since it's a macro, it can\n  automatically generate a forward declaration for add_impl, with the\n  correct signature. This means that if you use the wrong number and/or type\n  of parameters, you get a nice compile-time error instead of an obscure crash\n  at runtime.\n\n\nThe signature corresponding to HPyFunc_VARARGS is slighly different than\n  the old METH_VARARGS: we pass positional arguments as a C array instead of\n  a Python tuple. This means that it is possible to call the function without\n  having to allocate a Python tuple, and for example the PyPy implementation\n  of HPy takes advantage of that. This is very similar to CPython's\n  VectorCall protocol.\n\n\n\nNote\nIn this post, we are using a slightly old version of HPy. If you try with\na newer version you should use HPyContext *ctx instead of HPyContext ctx.\nSee also Issue #150\nand PR #182.\n\nLet's continue our tour of hello_new.c:\nstatic HPyDef *hello_defines[] = {\n    &add,\n    NULL\n};\n\nstatic HPyModuleDef moduledef = {\n    HPyModuleDef_HEAD_INIT,\n    .m_name = \"hello_new\",\n    .m_doc = \"hello example using the new HPy API\",\n    .m_size = -1,\n    .defines = hello_defines,\n};\n\nHPy_MODINIT(hello_new)\nstatic HPy init_hello_new_impl(HPyContext ctx) {\n    return HPyModule_Create(ctx, &moduledef);\n}\n\n\n\nThis is pretty similar to the old code. The biggest change is that instead of\ndeclaring an array of PyMethodDef, we create an array of HPyDef as\ndiscussed above.\nFinally, we need to modify setup.py. Compiling an HPy extension is as easy\nas adding setup_requires=['hpy.devel'] and use hpy_ext_modules:\n2021/03/hello-hpy/setup.py  (Source)from setuptools import setup, Extension\n\nsetup(\n    name=\"hello\",\n    ext_modules=[\n        Extension(\"hello_old\", [\"hello_old.c\"]),\n    ],\n    hpy_ext_modules=[\n        Extension(\"hello_new\", [\"hello_new.c\"]),\n    ],\n    setup_requires=[\"hpy.devel\"],\n)\n\n\nCompiling HPy extensions\nIn this demo, we will show how to setup an environment to try HPy and compile\nextensions on both CPython and PyPy.\nAt the moment HPy is still in its early stages and the API is still subject to\nchange, so we have not done any official release yet. For the same reason, if\nyou want to use HPy on PyPy or GraalPython, you need to manually ensure to install\na version which is supported. This is just temporary, and this kind of things will\nbe sorted out automatically once we start to roll out official releases.\nSo, we need to install HPy from the github repo. Moreover, the HPy\nimplementations inside PyPy and GraalPython are lagging behind a little, so we will\ninstall a slightly old revision:\n\n\nHPy revision eb07982\n\n\nnightly build of the PyPy hpy branch: a2f7c80062e8 for linux64\n\n\nPyPy nighly builds: main page and\n  hpy branch\n\n\nGraalPython nightly build: Linux or macOS\n\n\nsource code of this example\n\n\nThe first step is to create a venv for CPython and install hpy:\n$ python3 -m venv tryhpy\n$ . tryhpy/bin/activate\n$ pip install wheel\n$ pip install git+git://github.com/hpyproject/hpy.git@eb07982\n\n\n\nTo install a nightly build of PyPy it is enough to unpack the tarball and run\n-m ensurepip. We can check what is the HPy version supported by PyPy by\ncalling hpy.universal.get_version():\n$ curl -O http://buildbot.pypy.org/nightly/hpy/pypy-c-jit-101860-a2f7c80062e8-linux64.tar.bz2\n$ tar xf pypy-c-jit-101860-a2f7c80062e8-linux64.tar.bz2\n$ ./pypy-c-jit-101860-a2f7c80062e8-linux64/bin/pypy -m ensurepip\n\n$ ./pypy-c-jit-101860-a2f7c80062e8-linux64/bin/pypy\n>>>> import hpy.universal\n>>>> hpy.universal.get_version()\n('0.1.dev959+geb07982', 'eb07982')\n\n\n\nFor GraalPython, just unpack the tarball and create a venv:\n$ curl -LO https://github.com/graalvm/graalvm-ce-dev-builds/releases/download/21.1.0-dev-20210330_0726/graalpython-dev-linux-amd64.tar.gz\n$ tar xzf graalpython-dev-linux-amd64.tar.gz\n$ graalpython-21.1.0-dev-linux-amd64/bin/graalpython -m venv hpy-venv\n$ hpy-venv/bin/graalpython\n>>> import hpy.universal\n>>> hpy.universal.get_version()\n>>> ('0.1.dev950+g98f448a', '98f448a')\n\n\n\nNow that our enviroment is ready, we can compile and try our extensions:\n$ cd /path/to/example/\n$ . /path/to/tryhpy/bin/activate    # activate the venv\n$ python setup.py build_ext --inplace\n[...]\n\n$ ls -1 *.so\nhello_new.cpython-38-x86_64-linux-gnu.so\nhello_old.cpython-38-x86_64-linux-gnu.so\n\n$ python\n>>> import hello_old, hello_new\n>>> hello_old.add(10, 20)\n30\n>>> hello_new.add(30, 40)\n70\n>>>\n\n\n\nIt worked! One important thing to note is the filename of hello_new:\n.cpython-38-x86_64-linux-gnu.so is the standard filename for CPython 3.8\nextension modules. This happens because by default hpy_ext_modules targets\nthe\nCPython ABI. As\nsuch, from the point of view of CPython hello_new is indistinguishable from\nhello_old. It also means that HPy is required only to compile it but not to\nimport it later. Finally, we expect the performance to be the very same as the\nextensions using the old API.\nHowever, we can also explicitly ask HPy to produce an \"universal binary\",\nwhich targets the\nHPy Universal ABI:\nas the name implies, universal binaries can be imported by CPython, but also\nby alternative implementations such as PyPy. We can build universal binaries\nby passing --hpy-abi=universal to setup.py:\n$ # clean the previous build\n$ rm -rf build/ *.so\n\n$ python setup.py --hpy-abi=universal build_ext --inplace\n$ ls -1 *.so\nhello_new.hpy.so\nhello_old.cpython-38-x86_64-linux-gnu.so\n\n\n\nNote the filename: hello_old is still a CPython-specific extension, but\nhello_new.hpy.so is an universal binary. Once compiled, you can import it as\nusual:\n$ python\n>>> import hello_old, hello_new\n>>> hello_old.add(10, 20)\n30\n>>> hello_new.add(30, 40)\n70\n>>> hello_new.__file__\n'/.../hello-hpy/hello_new.hpy.so'\n\n\n\n\nNote\nAt the moment of writing, because of\nIssue #191 if you try to\nprint the repr of hello_new, you see something like this (note the .py\nextension):\n>>> hello_new\n<module 'hello_new' from '/.../hello-hpy/hello_new.py'>\n\n\n\n\nNote that on its own, CPython does not know how to import .hpy.so\nfiles. The magic is done by the hello_new.py, which is automatically\ngenerated by setup.py:\n$ cat hello_new.py\n[...]\ndef __bootstrap__():\n    [...]\n    from hpy.universal import load_from_spec\n    ext_filepath = pkg_resources.resource_filename(__name__, 'hello_new.hpy.so')\n    m = load_from_spec(Spec('hello_new', ext_filepath))\n    [...]\n    sys.modules[__name__] = m\n\n__bootstrap__()\n\n\n\nFinally, we can try to import our shiny new universal binary on PyPy:\n$ /path/to/pypy-c-jit-101860-a2f7c80062e8-linux64/bin/pypy\n>>>> import hello_new\n>>>> hello_new.add(10, 20)\n30\n>>>> hello_new.__file__\n'/.../hello-hpy/hello_new.hpy.so'\n>>>>\n\n\n\nSimilarly, it also just works on GraalPython:\n$ /path/to/graalpython/hpy-venv/bin/graalpython\n>>> import hello_new\n>>> hello_new.add(10, 20)\n30\n\n\n\nThat's all you need to get started with HPy. What we presented today is just\nthe basics, of course: in the next posts we will dig more into the technical\ndetails, and show more interesting features than just a hello world.\nStay tuned!\n(edited on 2021-03-31 to include GraalPython)",
      "tags": "",
      "url": "https://hpyproject.org/blog/posts/2021/03/hello-hpy/"
    },
    {
      "title": "Search",
      "text": "Search results appear here.",
      "tags": "",
      "url": "https://hpyproject.org/search/"
    }
  ]
};